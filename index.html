<!DOCTYPE html>
<html>
<head>
<title>HTML5 Canvas Paint</title>
<meta name="viewport" content="width=device-width, initial-scale=1" charset="utf-8"/>
<style>
body {
    font-family: Verdana,sans-serif;
    font-size: 13px;
}
canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
}
.btn-group .button {
    background-color: #ff5c33;
    border: 1px;
    color: white;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    cursor: pointer;
    float: left;
}
.btn-group .button:not(:last-child) {
    border-right: none;
}
.btn-group .button:hover {
    background-color: #e62e00;
}
</style>
</head>
<body>
<p id="currMousePos">Mouse position on canvas: </p>
<p id="status" hidden="true">Status: </p> <!-- Para testes necessários -->
<div class="btn-group">
  <button id="pointbt" class="button" onclick="s.setButton(this.id)">Point</button>
  <button id="linebt" class="button" onclick="s.setButton(this.id)">Line</button>
  <button id="polygonbt" class="button" onclick="s.setButton(this.id)">Polygon</button>
  <button id="polygonalbt" class="button" onclick="s.setButton(this.id)">Polygonal</button>
  <button id="translatebt" class="button" onclick="s.setButton(this.id)">Translate</button>
  <button id="rotatebt" class="button" onclick="s.setButton(this.id)">Rotate</button>
  <button id="scalebt" class="button" onclick="s.setButton(this.id)">Scale</button>
  <button id="mirrorbt" class="button" onclick="s.setButton(this.id)">Mirror</button>
  <button id="removebt" class="button" onclick="s.setButton(this.id)">Remove</button>
  <button id="convexhullbt" class="button" onclick="s.setButton(this.id)">Convex Hull</button>
</div>
<br><br><br><br>
<canvas id="myCanvas" width="1200" height="550">
</body>

<script>
var s = new CanvasState(document.getElementById("myCanvas"));
var shapeType = {
    POINT: 1,
    LINE: 2,
    POLYGON: 3,
    POLYGONAL: 4,
    CONVEX: 5,
};

// Um ponto contém a sua coordenada x, y
function Point(x, y) {
    this.x = x || 0;
    this.y = y || 0;
    this.w = this.h = 6;
    this.fill = '#000000';
    this.shapeType = shapeType.POINT;
}

// Uma linha contém uma coordenada inicial (start) e uma coordenada final (end)
function Line(start, end) {
    this.start = start || {x: 0, y: 0};
    this.end = end || {x: 0, y: 0};
    this.stroke = '#000000';
    this.width = 1;
    this.shapeType = shapeType.LINE;
}

function Polygon() {
    this.lines = [];
    this.stroke = '#000000';
    this.width = 1;
    this.shapeType = shapeType.POLYGON;
}

Polygon.prototype.getLinesLength = function() {
    var l = this.lines.length;
    return l;
}

function Polygonal() {
    this.lines = [];
    this.stroke = '#000000';
    this.width = 1;
    this.shapeType = shapeType.POLYGONAL;
}

Polygonal.prototype.getLinesLength = function() {
    var l = this.lines.length;
    return l;
}

function ConvexHull() {
    this.lines = [];
    this.stroke = '#0000ff'
    this.width = 2;
    this.shapeType = shapeType.CONVEX;
}

ConvexHull.prototype.getLinesLength = function() {
    var l = this.lines.length;
    return l;
}

// Um objeto é um vetor com n formas
// Podem ser um ponto, uma linha ou um polígono
function Object(shape) {
    this.shape = shape;
    this.shapeType = shape.shapeType;
}

// Determina se a posição do mouse é válida sobre as formas
Object.prototype.contains = function(currMousePos) {
    if(this.shapeType == shapeType.POINT) {
        return this.pickPoint(currMousePos);
    } else if(this.shapeType == shapeType.LINE) {
        return this.pickLine(currMousePos);
    } else if(this.shapeType == shapeType.POLYGON) {
        return this.pickPolygon(currMousePos);
    } else if(this.shapeType == shapeType.POLYGONAL) {
        return this.pickPolygonal(currMousePos);
    } else return false;
}

// Determina se a posição do mouse é válida sobre pontos
Object.prototype.pickPoint = function(currMousePos) {
    return (this.shape.x <= currMousePos.x) && (this.shape.x + this.shape.w >= currMousePos.x) &&
           (this.shape.y <= currMousePos.y) && (this.shape.y + this.shape.h >= currMousePos.y)
}

// Calcula código de 4 elementos para pick de linha
Object.prototype.pickCode = function(x, y, xmin, xmax, ymin, ymax, cod) {
    cod[0] = x < xmin;
    cod[1] = x > xmax;
    cod[2] = y < ymin;
    cod[3] = y > ymax;
}

// Determina se a posição do mouse é válida sobre linhas
Object.prototype.pickLine = function(currMousePos) {
    var cod0 = [], cod1 = [];
    var x0, y0, x1, y1;
    var xmin, xmax, ymin, ymax;
    var TOL = 5; // 5 pixels de tolerância

    // Define os limites baseado na tolerância
    xmin = currMousePos.x - TOL;
    xmax = currMousePos.x + TOL;
    ymin = currMousePos.y - TOL;
    ymax = currMousePos.y + TOL;

    // Testa a reta
    var line = this.shape;
    x0 = line.start.x;
    y0 = line.start.y;
    x1 = line.end.x;
    y1 = line.end.y;
    this.pickCode(x1, y1, xmin, xmax, ymin, ymax, cod1);
    do {
        this.pickCode(x0, y0, xmin, xmax, ymin, ymax, cod0);
        for(var j = 0; j < 4; j++) {
            if(cod0[j] && cod1[j]) break;
        }
        if(j != 4) break;
        if(cod0[0]) y0 += (xmin - x0) * (y1 - y0) / (x1 - x0), x0 = xmin;
        else if(cod0[1]) y0 += (xmax - x0) * (y1 - y0) / (x1 - x0), x0 = xmax;
        else if(cod0[2]) x0 += (ymin - y0) * (x1 - x0) / (y1 - y0), y0 = ymin;
        else if(cod0[3]) x0 += (ymax - y0) * (x1 - x0) / (y1 - y0), y0 = ymax;
        else return true;
    } while(true);
    return false;
}

// Determina se a posição do mouse é válida dentro de um polígono
Object.prototype.pickPolygon = function(currMousePos) {
    var polygon = this.shape;
    var l = polygon.getLinesLength();
    var ni = 0; // Número de interseções
    var fst = l - 1; // Última aresta
    var lines = polygon.lines;

    for(var i = 0; i < l; i++) {
        let p1 = lines[i].start; // Primeiro vértice
        let p2 = lines[fst].start; // Último vértice
        if(!(p1.y == p2.y) && // Descarta horizontais
           !((p1.y > currMousePos.y) && (p2.y > currMousePos.y)) && // Descarta retas acima
           !((p1.y < currMousePos.y) && (p2.y < currMousePos.y)) && // Descarta retas abaixo
           !((p1.x < currMousePos.x) && (p2.x < currMousePos.x))) { // Descartas retas a esquerda
            if(p1.y == currMousePos.y) { // Primeiro ponto na mesma cota
                if((p1.x > currMousePos.x) && (p2.y > currMousePos.y)) ni++; // A direita e acima do ponto
            } else {
                if(p2.y == currMousePos.y) { // Segundo ponto na mesma cota
                    if((p2.x > currMousePos.x) && (p1.y > currMousePos.y)) ni++; // A direita e acima do ponto
                } else {
                    if((p1.x > currMousePos.x) && (p2.x > currMousePos.x)) ni++; // Inteiramente a direita
                    else { // Verifica ponto de interseção
                        let dx = p1.x - p2.x;
                        let xc = p1.x;
                        if(dx != 0) xc += (currMousePos.y - p1.y) * dx / (p1.y - p2.y);
                        if(xc > currMousePos.x) ni++;
                    }
                }
            }
        }
        fst = i;
    }
    if(ni % 2 == 0) return false;
    else return true;
}

// Determina se a posição do mouse é válida dentro de uma poligonal
Object.prototype.pickPolygonal = function(currMousePos) {
    var cod0 = [], cod1 = [];
    var x0, y0, x1, y1;
    var xmin, xmax, ymin, ymax;
    var TOL = 5; // 5 pixels de tolerância

    // Define os limites baseado na tolerância
    xmin = currMousePos.x - TOL;
    xmax = currMousePos.x + TOL;
    ymin = currMousePos.y - TOL;
    ymax = currMousePos.y + TOL;

    var l = this.shape.getLinesLength();
    for(var i = 0; i < l; i++) {
        var line = this.shape.lines[i];
        x0 = line.start.x;
        y0 = line.start.y;
        x1 = line.end.x;
        y1 = line.end.y;
        this.pickCode(x1, y1, xmin, xmax, ymin, ymax, cod1);
        do {
            this.pickCode(x0, y0, xmin, xmax, ymin, ymax, cod0);
            for(var j = 0; j < 4; j++) {
                if(cod0[j] && cod1[j]) break;
            }
            if(j != 4) break;
            if(cod0[0]) y0 += (xmin - x0) * (y1 - y0) / (x1 - x0), x0 = xmin;
            else if(cod0[1]) y0 += (xmax - x0) * (y1 - y0) / (x1 - x0), x0 = xmax;
            else if(cod0[2]) x0 += (ymin - y0) * (x1 - x0) / (y1 - y0), y0 = ymin;
            else if(cod0[3]) x0 += (ymax - y0) * (x1 - x0) / (y1 - y0), y0 = ymax;
               else return true;
        } while(true);
    }
    return false;
}

// Desenha o objeto em um context
Object.prototype.draw = function(ctx) {
    // Desenha cada linha de um objeto
    var shape = this.shape;
    if(this.shapeType == shapeType.POINT) {
        ctx.fillStyle = shape.fill;
        ctx.fillRect(shape.x, shape.y, shape.w, shape.h);
    } else if(this.shapeType == shapeType.LINE) {
        ctx.beginPath();
        ctx.moveTo(shape.start.x, shape.start.y);
        ctx.lineTo(shape.end.x, shape.end.y);
        ctx.strokeStyle = shape.stroke;
        ctx.lineWidth = shape.width;
        ctx.stroke();
    } else if(this.shapeType == shapeType.POLYGON) {
        var l = shape.getLinesLength();
        for(var i = 0; i < l; i++) {
            var line = shape.lines[i];
            ctx.beginPath();
            ctx.moveTo(line.start.x, line.start.y);
            ctx.lineTo(line.end.x, line.end.y);
            ctx.strokeStyle = shape.stroke;
            ctx.lineWidth = shape.width;
            ctx.stroke();
        }
    } else if(this.shapeType == shapeType.POLYGONAL) {
        var l = shape.getLinesLength();
        for(var i = 0; i < l; i++) {
            var line = shape.lines[i];
            ctx.beginPath();
            ctx.moveTo(line.start.x, line.start.y);
            ctx.lineTo(line.end.x, line.end.y);
            ctx.strokeStyle = shape.stroke;
            ctx.lineWidth = shape.width;
            ctx.stroke();
        }
    } else if(this.shapeType == shapeType.CONVEX) {
        var l = shape.getLinesLength();
        for(var i = 0; i < l; i++) {
            var line = shape.lines[i];
            ctx.beginPath();
            ctx.moveTo(line.start.x, line.start.y);
            ctx.lineTo(line.end.x, line.end.y);
            ctx.strokeStyle = shape.stroke;
            ctx.lineWidth = shape.width;
            ctx.stroke();
        }
    }
}

// CanvasState toma conta do estado do canvas
// Nele encontram-se os métodos para eventos do mouse, e também métodos de update no canvas, no caso de alguma movimentação ou transformação em algum objeto presente nele
// Os objetos (pontos, linhas, polígonos e poligonais) são salvos na lista objects[]
function CanvasState(canvas) {
    // Atributos
    this.canvas = canvas;
    this.width = canvas.width;
    this.height = canvas.height;
    this.ctx = canvas.getContext('2d');

    this.valid = false;
    this.objects = [];  // Objetos criados na tela
    this.dragging = false; // Flag para quando se está arrastando um objeto
    this.drawing = false; // Flag para quando se está desenhando um objeto
    this.rotating = false; // Flag para quando se está rotacionando um objeto
    this.selection = null; // Objeto selecionado
    this.startline = true; // Usado para desenhar linhas
    this.prevMousePos = {x: 0, y: 0}; // Salva o primeiro click do mouse ao desenhar
    this.rotationCenter = {x: 0, y: 0}; // Centro de rotação
    this.mouseDownFired = false; // Usado para mover sem desenhar
    this.button = 0; // Botão selecionado
    this.newPolygon = null; // Polígono a ser adicionado
    this.newPolygonal = null; // Polígonal a ser adicionada
    this.objectIndex = -1; // Auxilia na remoção
    this.mline = null; // Auxilia no espelhamento

    // Dentro dos eventos do mouse, o "this" corresponde ao canvas, por isso precisa-se guardar o CanvasState em uma variável
    var myState = this;

    canvas.addEventListener('mousemove', function(e) {
        var currMousePos = myState.getMousePos(e);
        if(myState.drawing) {
            if(myState.button == 2) {
                myState.drawLine(currMousePos);
            } else if(myState.button == 3) {
                myState.drawPolygon(currMousePos);
            } else if(myState.button == 4) {
                myState.drawPolygonal(currMousePos);
            } else if(myState.button == 8) {
                myState.drawMirrorLine(currMousePos);
            }
            myState.valid = false;
        } else if(myState.dragging) {
            myState.dragShape(currMousePos);
            myState.valid = false;
        } else if(myState.rotating) {
            myState.rotateShape(currMousePos);
            myState.valid = false;
        }
        myState.writeMousePos("Mouse position on canvas: " + currMousePos.x + ',' + currMousePos.y);
    }, true);


    canvas.addEventListener('click', function(e) {
        // Se 'mousedown' estiver ativo, 'click' não será disparado
        if(myState.mouseDownFired) {
            myState.mouseDownFired = false;
            return;
        }
        var currMousePos = myState.getMousePos(e);
        if(myState.button == 1) {
            myState.addObject(new Point(currMousePos.x - 3, currMousePos.y - 3));
        } else if(myState.button == 2) {
            if(myState.startline) { // Primeiro click
                myState.startline = false; 
                myState.drawing = true;
                myState.prevMousePos = currMousePos;
            } else {                // Segundo click
                myState.startline = true; 
                myState.drawing = false;
                myState.addObject(new Line(myState.prevMousePos, currMousePos));
            }
        } else if(myState.button == 3) {
            if(myState.startline) {
                myState.newPolygon = new Polygon();
                myState.startline = false;
                myState.drawing = true;
                myState.prevMousePos = currMousePos;
                myState.addObject(myState.newPolygon);
            } else {
                if((myState.prevMousePos.x != currMousePos.x) && (myState.prevMousePos.y != currMousePos.y)) {
                    var polygon = myState.objects[myState.getObjectsLength() - 1].shape;
                    polygon.lines.push(new Line(myState.prevMousePos, currMousePos));
                    myState.prevMousePos = currMousePos;
                }
            }
        } else if(myState.button == 4) {
            if(myState.startline) {
                myState.newPolygonal = new Polygonal();
                myState.startline = false;
                myState.drawing = true;
                myState.prevMousePos = currMousePos;
                myState.addObject(myState.newPolygonal);
            } else {
                if((myState.prevMousePos.x != currMousePos.x) && (myState.prevMousePos.y != currMousePos.y)) {
                    var polygonal = myState.objects[myState.getObjectsLength() - 1].shape;
                    polygonal.lines.push(new Line(myState.prevMousePos, currMousePos));
                    myState.prevMousePos = currMousePos;
                }
            }
        } else if(myState.button == 6) {
            var objects = myState.objects;
            var l = myState.getObjectsLength();
            for(var i = l - 1; i >= 0; i--) {
                if(objects[i].contains(currMousePos)) {
                    myState.selection = objects[i].shape;
                    myState.valid = false;
                    return;
                }
            }
        } else if(myState.button == 7) {
            var objects = myState.objects;
            var l = myState.getObjectsLength();
            for(var i = l - 1; i >= 0; i--) {
                if(objects[i].contains(currMousePos)) {
                    myState.selection = objects[i].shape;
                    myState.valid = false;
                    return;
                }
            }
        } else if(myState.button == 8) {
            if(myState.selection != null) {
                if(myState.startline) { // Primeiro click
                    myState.startline = false; 
                    myState.drawing = true;
                    myState.prevMousePos = currMousePos;
                } else {                // Segundo click
                    myState.mline = new Line(myState.prevMousePos, currMousePos);
                    myState.mirrorShape();
                    myState.startline = true; 
                    myState.drawing = false;
                    myState.selection = null;
                    myState.valid = false;
                }
                return;
            } else {
                var objects = myState.objects;
                var l = myState.getObjectsLength();
                for(var i = l - 1; i >= 0; i--) {
                    if(objects[i].contains(currMousePos)) {
                        myState.selection = objects[i].shape;
                        myState.valid = false;
                        return;
                    }
                }
            }
        } else if(myState.button == 9) {
            var objects = myState.objects;
            var l = myState.getObjectsLength();
            for(var i = l - 1; i >= 0; i--) {
                if(objects[i].contains(currMousePos)) {
                    myState.selection = objects[i].shape;
                    myState.objectIndex = i;
                    myState.valid = false;
                    return;
                }
            }
        }

        if(myState.selection) {
            myState.selection = null;
            myState.valid = false;
        }
    }, true);

    canvas.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        // Finaliza o polígono
        if(myState.newPolygon != null || myState.newPolygonal != null) {
            myState.resetState();
        }
        if(myState.button == 9) {
            if(myState.objectIndex >= 0) {
                myState.removeObject(myState.objectIndex);
                myState.objectIndex = -1;
                myState.valid = false;
            }
        }
        return false;
    });

    canvas.addEventListener('mousedown', function(e) {
        // Previne disparar um 'click'
        myState.mouseDownFired = true;
        if(myState.button == 5) {
            var currMousePos = myState.getMousePos(e);
            var objects = myState.objects;
            var l = myState.getObjectsLength();
            for(var i = l - 1; i >= 0; i--) {
                if(objects[i].contains(currMousePos)) {
                    myState.selection = objects[i].shape;
                    myState.prevMousePos = currMousePos;
                    myState.dragging = true;
                    myState.valid = false;
                    return;
                }
            }
        } else if(myState.button == 6) {
            var currMousePos = myState.getMousePos(e);
            if(myState.selection != null) {
                myState.rotationCenter = currMousePos;
                myState.prevMousePos = currMousePos;
                myState.rotating = true;
                myState.valid = false;
                return;
            }
        } else if(myState.button == 8) {
            if(myState.selection != null) {
                myState.mouseDownFired = false;
                return;
            }
        }

        if(myState.selection) {
            myState.selection = null;
            myState.valid = false;
        }
        // Permite disparar um 'click'
        myState.mouseDownFired = false;
    });

    canvas.addEventListener('mouseup', function(e) {
        myState.dragging = false;
        if(myState.rotating) {
            myState.rotating = false;
            myState.mouseDownFired = false;
        }
    });

    // IE, Chrome, Safari, Opera
    canvas.addEventListener('mousewheel', function(e) {
        if(myState.button == 7 && myState.selection != null) {
            var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
            delta = (delta * 0.3) + 1;
            var shapeS = scale(myState.selection, delta, delta);
            myState.scaleShape(shapeS);
            myState.valid = false;
        }
    });

    // Firefox
    canvas.addEventListener('DOMMouseScroll', function(e) {
        if(myState.button == 7 && myState.selection != null) {
            var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
            delta = (delta * 0.3) + 1;
            var shapeS = scale(myState.selection, delta, delta);
            myState.scaleShape(shapeS);
            myState.valid = false;
        }
    });

    this.selectionColor = '#CC0000';
    this.selectionWidth = 2; 
    this.interval = 10;
    setInterval(function() { myState.draw(); }, myState.interval);
}

// Adiciona um objeto à lista de objetos do canvas
CanvasState.prototype.addObject = function(shape) {
    var o = new Object(shape);
    this.objects.push(o);
    this.valid = false;
}

CanvasState.prototype.removeObject = function(i) {
    this.objects.splice(i, 1);
}

// Limpa a tela para redesenhar o canvas em cada interval
CanvasState.prototype.clear = function() {
    this.ctx.clearRect(0, 0, this.width, this.height);
}

// Método chamado pelo INTERVAL
// Limpa o canvas e redesenha todos os objetos presentes em objects[]
CanvasState.prototype.draw = function() {
    if(!this.valid) {
        var ctx = this.ctx;
        //var objects = this.objects;
        this.clear();
        if(this.drawing) ctx.stroke(); // Evita que desenhe a mesma linha duas vezes

        // Desenha todos os objetos
        this.ctx.setLineDash([0, 0]);
        var l = this.getObjectsLength();
        for(var i = 0; i < l; i++) {
            var object = this.objects[i];
            this.objects[i].draw(ctx);
        }

        if(this.selection != null) {
            ctx.strokeStyle = this.selectionColor;
            ctx.lineWidth = this.selectionWidth;
            var mySel = this.selection;
            if(mySel.shapeType == shapeType.POINT) {
                ctx.strokeRect(mySel.x, mySel.y, mySel.w, mySel.h);
            } else if(mySel.shapeType == shapeType.LINE) {
                ctx.beginPath();
                ctx.moveTo(mySel.start.x, mySel.start.y);
                ctx.lineTo(mySel.end.x, mySel.end.y);
                ctx.stroke();
            } else if(mySel.shapeType == shapeType.POLYGON) {
                var l = mySel.getLinesLength();
                for(var i = 0; i < l; i++) {
                    var line = mySel.lines[i];
                    ctx.beginPath();
                    ctx.moveTo(line.start.x, line.start.y);
                    ctx.lineTo(line.end.x, line.end.y);
                    ctx.stroke();
                }
            } else if(mySel.shapeType == shapeType.POLYGONAL) {
                var l = mySel.getLinesLength();
                for(var i = 0; i < l; i++) {
                    var line = mySel.lines[i];
                    ctx.beginPath();
                    ctx.moveTo(line.start.x, line.start.y);
                    ctx.lineTo(line.end.x, line.end.y);
                    ctx.stroke();
                }
            }
        }

        this.valid = true;
    }
}

CanvasState.prototype.getMousePos = function(e) {
    var rect = this.canvas.getBoundingClientRect();
    return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
}

CanvasState.prototype.writeMousePos = function(message) {
    document.getElementById("currMousePos").innerHTML = message;
}

CanvasState.prototype.drawLine = function(currMousePos) {
    this.ctx.beginPath();
    this.ctx.moveTo(this.prevMousePos.x, this.prevMousePos.y);
    this.ctx.lineTo(currMousePos.x, currMousePos.y);
}

CanvasState.prototype.drawPolygon = function(currMousePos) {
    var polygon = this.objects[this.getObjectsLength() - 1].shape;
    if(polygon.getLinesLength() == 0) {
        this.drawLine(currMousePos);
    } else {
        var start = polygon.lines[0].start;
        this.ctx.beginPath();
        this.ctx.moveTo(this.prevMousePos.x, this.prevMousePos.y);
        this.ctx.lineTo(currMousePos.x, currMousePos.y);
        this.ctx.lineTo(start.x, start.y);
    }
}

CanvasState.prototype.drawPolygonal = function(currMousePos) {
    var polygonal = this.objects[this.getObjectsLength() - 1].shape;
    if(polygonal.getLinesLength() == 0) {
        this.drawLine(currMousePos);
    } else {
        this.ctx.beginPath();
        this.ctx.moveTo(this.prevMousePos.x, this.prevMousePos.y);
        this.ctx.lineTo(currMousePos.x, currMousePos.y);
    }
}

CanvasState.prototype.dragShape = function(currMousePos) {
    var v = vector(this.prevMousePos, currMousePos);
    var newPosition;
    if(this.selection.shapeType == shapeType.POINT) {
        newPosition = translate(this.selection, v);
        this.selection.x = newPosition.x;
        this.selection.y = newPosition.y;
    } else if(this.selection.shapeType == shapeType.LINE) {
        newPosition = translate(this.selection.start, v);
        this.selection.start = newPosition;
        newPosition = translate(this.selection.end, v);
        this.selection.end = newPosition;
    } else if(this.selection.shapeType == shapeType.POLYGON) {
        var l = this.selection.getLinesLength();
        for(var i = 0; i < l; i++) {
            var line = this.selection.lines[i];
            newPosition = translate(line.start, v);
            line.start = newPosition;
            newPosition = translate(line.end, v);
            line.end = newPosition;
        }
    } else if(this.selection.shapeType == shapeType.POLYGONAL) {
        var l = this.selection.getLinesLength();
        for(var i = 0; i < l; i++) {
            var line = this.selection.lines[i];
            newPosition = translate(line.start, v);
            line.start = newPosition;
            newPosition = translate(line.end, v);
            line.end = newPosition;
        }
    }
    this.prevMousePos = currMousePos;
}

CanvasState.prototype.rotateShape = function(currMousePos) {
    var dragx = currMousePos.x - this.prevMousePos.x;
    var ang = 0;
    if(dragx > 0) ang = -0.1;
    else if(dragx < 0) ang = 0.1;

    if(this.selection.shapeType == shapeType.POINT && ang != 0) {
        var newPosition = rotate(this.selection, this.rotationCenter, Math.cos(-ang), Math.sin(-ang));
        this.selection.x = newPosition.x;
        this.selection.y = newPosition.y;
    } else if(this.selection.shapeType == shapeType.LINE) {
        var newStart = rotate(this.selection.start, this.rotationCenter, Math.cos(-ang), Math.sin(-ang));
        var newEnd = rotate(this.selection.end, this.rotationCenter, Math.cos(-ang), Math.sin(-ang));
        this.selection.start = newStart;
        this.selection.end = newEnd;
    } else if(this.selection.shapeType == shapeType.POLYGON) {
        var l = this.selection.getLinesLength();
        for(var i = 0; i < l; i++) {
            var line = this.selection.lines[i];
            var newStart = rotate(line.start, this.rotationCenter, Math.cos(-ang), Math.sin(-ang));
            var newEnd = rotate(line.end, this.rotationCenter, Math.cos(-ang), Math.sin(-ang));
            line.start = newStart;
            line.end = newEnd;
        }
    }else if(this.selection.shapeType == shapeType.POLYGONAL) {
        var l = this.selection.getLinesLength();
        for(var i = 0; i < l; i++) {
            var line = this.selection.lines[i];
            var newStart = rotate(line.start, this.rotationCenter, Math.cos(-ang), Math.sin(-ang));
            var newEnd = rotate(line.end, this.rotationCenter, Math.cos(-ang), Math.sin(-ang));
            line.start = newStart;
            line.end = newEnd;
        }
    }
    this.prevMousePos = currMousePos;
}

CanvasState.prototype.scaleShape = function(shape) {
    if(shape) {
        if(shape.shapeType == shapeType.LINE) {
            this.selection.start = shape.start;
            this.selection.end = shape.end;
        } else if(shape.shapeType == shapeType.POLYGON) {
            var polygon = this.selection;
            var l = polygon.getLinesLength();
            for(var i = 0; i < l; i++) {
                polygon.lines[i].start = shape.lines[i].start;
                polygon.lines[i].end = shape.lines[i].end;
            }
        } else if(shape.shapeType == shapeType.POLYGONAL) {
            var polygon = this.selection;
            var l = polygon.getLinesLength();
            for(var i = 0; i < l; i++) {
                polygon.lines[i].start = shape.lines[i].start;
                polygon.lines[i].end = shape.lines[i].end;
            }
        }
    }     
}

CanvasState.prototype.drawMirrorLine = function(currMousePos) {
    this.ctx.setLineDash([5, 3]);
    this.ctx.strokeStyle = "#000000";
    this.ctx.lineWidth = 1;
    this.drawLine(currMousePos);
    this.valid = false;
}

CanvasState.prototype.mirrorShape = function() {
    if(this.selection.shapeType == shapeType.POINT) {
        var newPosition = mirror(this.selection, this.mline);
        this.selection.x = newPosition.x;
        this.selection.y = newPosition.y;
    } else if(this.selection.shapeType == shapeType.LINE) {
        var newStart = mirror(this.selection.start, this.mline);
        var newEnd = mirror(this.selection.end, this.mline);
        this.selection.start = newStart;
        this.selection.end = newEnd;
    } else if(this.selection.shapeType == shapeType.POLYGON) {
        var l = this.selection.getLinesLength();
        for(var i = 0; i < l; i++) {
            var line = this.selection.lines[i];
            var newStart = mirror(line.start, this.mline);
            var newEnd = mirror(line.end, this.mline);
            line.start = newStart;
            line.end = newEnd;
        }
    } else if(this.selection.shapeType == shapeType.POLYGONAL) {
        var l = this.selection.getLinesLength();
        for(var i = 0; i < l; i++) {
            var line = this.selection.lines[i];
            var newStart = mirror(line.start, this.mline);
            var newEnd = mirror(line.end, this.mline);
            line.start = newStart;
            line.end = newEnd;
        }
    }
}

CanvasState.prototype.executeConvexHull = function() {
    var points = [];
    var l = this.getObjectsLength();
    for(var i = 0; i < l; i++) {
        var shape = this.objects[i].shape;
        if(shape.shapeType == shapeType.POINT) {
            points.push({x: shape.x, y: shape.y});
        } else if(shape.shapeType == shapeType.LINE) {
            points.push(shape.start);
            points.push(shape.end);
        } else if(shape.shapeType == shapeType.POLYGON) {
            var pl = shape.getLinesLength();
            for(var j = 0; j < pl; j++) {
                points.push(shape.lines[j].start);
            }
        } else if(shape.shapeType == shapeType.POLYGONAL) {
            var pl = shape.getLinesLength();
            for(var j = 0; j < pl; j++) {
                points.push(shape.lines[j].start);
            }
            points.push(shape.lines[j-1].end);
        }
    }
    
    if(points.length >= 3) {
        var hull = convexHull(points);
        var l = hull.length;
        var ch = new ConvexHull();
        for(var i = 0; i < l; i++) {
            if(i == l-1) {
                ch.lines.push(new Line(hull[i], hull[0]));
            } else {
                ch.lines.push(new Line(hull[i], hull[i+1]));
            }
        }
        this.addObject(ch);
    }    
}

CanvasState.prototype.setButton = function(id) {
    this.resetState();
    switch(id) {
        case "pointbt"     : this.button = 1; break;
        case "linebt"      : this.button = 2; break;
        case "polygonbt"   : this.button = 3; break;
        case "polygonalbt" : this.button = 4; break;
        case "translatebt" : this.button = 5; break;
        case "rotatebt"    : this.button = 6; break;
        case "scalebt"     : this.button = 7; break;
        case "mirrorbt"    : this.button = 8; break;
        case "removebt"    : this.button = 9; break;
        case "convexhullbt": this.button = 10; 
                             this.executeConvexHull(); 
                             break;
        default            : this.button = 0;
    }
}

// Reinicia várias opções importantes ao canvas para evitar conflitos e bugs
CanvasState.prototype.resetState = function() {
    this.closePolygon();
    this.removeConvex();
    this.ctx.beginPath();
    this.ctx.strokeStyle = "#000000";
    this.ctx.lineWidth = 1;
    this.newPolygon = null;
    this.newPolygonal = null;
    this.mline = null;
    this.selection = null;
    this.startline = true;
    this.drawing = false;
    this.valid = false;
}

CanvasState.prototype.closePolygon = function() {
    if(this.getObjectsLength() > 0) {
        var polygon = this.objects[this.getObjectsLength() - 1].shape;
        if(polygon.shapeType == shapeType.POLYGON) {
            var l = polygon.getLinesLength();
            // Caso não seja fechado um polígono com no mínimo 3 linhas, remove-o da lista de objetos
            if(l <= 1) {
                this.removeObject(this.getObjectsLength() - 1);
                return;
            }
            // Caso contrário, fecha-o unindo o ponto inicial da primeira aresta com o ponto final da última aresta
            var lineStart = polygon.lines[0];
            var lineEnd = polygon.lines[l - 1];
            // Testa se o polígono já está fechado
            if(lineStart.start.x != lineEnd.end.x && lineStart.start.y != lineEnd.end.y) {
                polygon.lines.push(new Line(lineEnd.end, lineStart.start));
            }
        }
    }
}

// Remove convex hull desenhado no canvas
CanvasState.prototype.removeConvex = function() {
    if(this.getObjectsLength() > 0) {
        var shape = this.objects[this.getObjectsLength() - 1].shape;
        if(shape.shapeType == shapeType.CONVEX) {
            this.removeObject(this.getObjectsLength() - 1);
        }
    }
}

// Método de auxílio
CanvasState.prototype.isMovable = function(currMousePos) {
    var l = this.getObjectsLength();
    for(var i = 0; i < l; i++) {
        var object = this.objects[i];
        var movable = object.contains(currMousePos);
        if(movable) break;
    }
    document.getElementById("status").innerHTML = "Status: " + movable;
}

CanvasState.prototype.getObjectsLength = function() {
    var l = this.objects.length;
    return l;
}

function multMatrix(m1, m2) {
    var m1Rows = m1.length, m1Cols = m1[0].length,
        m2Rows = m2.length, m2Cols = m2[0].length;
    var m = new Array(m1Rows);
    for(var i = 0; i < m1Rows; i++) {
        m[i] = new Array(m2Cols);
        for(var j = 0; j < m2Cols; j++) {
            m[i][j] = 0;
            for(var k = 0; k < m1Cols; k++) {
                m[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }
    return m;
}

function vector(p1, p2) {
    return {x: p2.x - p1.x, y: p2.y - p1.y};
}

// Translada o ponto p
function translate(p, vt) { // p: ponto; vt: vetor de translação
    var pTranslated = {x: 0, y: 0};
    var m1 = [
      [1, 0, vt.x],
      [0, 1, vt.y],
      [0, 0, 1]
    ];
    var m2 = [
      [p.x],
      [p.y],
      [1]
    ];
    var m = multMatrix(m1, m2);
    pTranslated.x = m[0][0];
    pTranslated.y = m[1][0];

    return pTranslated;
}

// Rotaciona o ponto p
function rotate(p, pr, cos, sin) { // p: ponto; pr: ponto de rotação
    var pRotated = {x: 0, y: 0};
    var m1 = [
      [cos, -sin, 0],
      [sin, cos, 0],
      [0, 0, 1]
    ];
    var v = vector(pr, {x: 0, y: 0});
    var p0 = translate(p, v); // Translada o ponto para o centro de rotação ficar na origem
    var m2 = [
      [p0.x],
      [p0.y],
      [1]
    ];
    var m = multMatrix(m1, m2); // Rotaciona
    var p1 = {x: 0, y: 0};
    p1.x = m[0][0];
    p1.y = m[1][0];
    v = vector({x: 0, y: 0}, pr);
    pRotated = translate(p1, v); // Retorna ao ponto original rotacionado

    return pRotated;
}

// Escala uma forma
function scale(shape, sx, sy) {
    if(shape.shapeType == shapeType.LINE) {
        var start = shape.start, end = shape.end;
        var mp = midPoint(start, end);
        var v = vector(mp, {x: 0, y: 0});
        start = translate(start, v);
        end = translate(end, v);
        start = scaleP(start, sx, sy);
        end = scaleP(end, sx, sy);
        return new Line(translate(start, mp), translate(end, mp));
    } else if(shape.shapeType == shapeType.POLYGON) {
        var l = shape.getLinesLength();
        var newPolygon = new Polygon();
        var mp = {x: 0, y: 0};

        // Ponto central ao polígono
        for(var i = 0; i < l; i++) {
            var line = shape.lines[i];
            mp.x += line.end.x / l;
            mp.y += line.end.y / l;
        }

        // Escala o polígono
        for(var i = 0; i < l; i++) {
            var line = shape.lines[i];
            var start = line.start, end = line.end;
            var v = vector(mp, {x: 0, y: 0});
            start = translate(start, v);
            end = translate(end, v);
            start = scaleP(start, sx, sy);
            end = scaleP(end, sx, sy);
            newPolygon.lines.push(new Line(translate(start, mp), translate(end, mp)));
        }
        return newPolygon;
    } else if(shape.shapeType == shapeType.POLYGONAL) {
        var l = shape.getLinesLength();
        var newPolygonal = new Polygonal();
        var mp = {x: 0, y: 0};

        // Se a poligonal possui apenas uma linha
        if(l == 1) {
            var line = shape.lines[0];
            var start = line.start, end = line.end;
            mp = midPoint(start, end);
            var v = vector(mp, {x: 0, y: 0});
            start = translate(start, v);
            end = translate(end, v);
            start = scaleP(start, sx, sy);
            end = scaleP(end, sx, sy);
            newPolygonal.lines.push(new Line(translate(start, mp), translate(end, mp)));
            return newPolygonal;
        }

        // Ponto central a poligonal
        for(var i = 0; i < l; i++) {
            var line = shape.lines[i];
            mp.x += line.end.x / l;
            mp.y += line.end.y / l;
        }

        // Escala a poligonal
        for(var i = 0; i < l; i++) {
            var line = shape.lines[i];
            var start = line.start, end = line.end;
            var v = vector(mp, {x: 0, y: 0});
            start = translate(start, v);
            end = translate(end, v);
            start = scaleP(start, sx, sy);
            end = scaleP(end, sx, sy);
            newPolygonal.lines.push(new Line(translate(start, mp), translate(end, mp)));
        }
        return newPolygonal;
    }
}

// Escala o ponto p
function scaleP(p, sx, sy) {
    var pScaled = {x: 0, y: 0}
    var m1 = [
      [sx, 0, 0],
      [0, sy, 0],
      [0, 0, 1]
    ];
    var m2 = [
      [p.x],
      [p.y],
      [1]
    ];
    var m = multMatrix(m1, m2);
    pScaled.x = m[0][0];
    pScaled.y = m[1][0];

    return pScaled;
}

function mirror(p, mline) {
    var start = mline.start;
    var end = mline.end;
    var dx, dy, a, b, x, y;

    dx = end.x - start.x;
    dy = end.y - start.y;
    a = (dx * dx - dy * dy) / (dx * dx + dy * dy);
    b = 2 * dx * dy / (dx * dx + dy * dy);
    x = Math.round(a * (p.x - start.x) + b * (p.y - start.y) + start.x); 
    y = Math.round(b * (p.x - start.x) - a * (p.y - start.y) + start.y);

    return {x: x, y: y};
}

/*
function mirror(shape, rline) {
    // Steps:
    // 1. Translada linha e ponto para o eixo x, até o extremo da linha com menor y ter x = 0
    // 2. Rotaciona linha e ponto em relação ao extremo da linha em que y = 0
    // 3. Espelha
    // 4. Rotaciona de volta
    // 5. Translada de volta


    // Para pontos
    // Step 1:
    var pt = {x: 0, y: 0}; // Ponto de translação
    var po = {x: 0, y: 0}; // Ponto oposto ao de translação
    var p = {x: shape.x, y: shape.y};

    if(rline.start.y == rline.end.y || rline.start.y < rline.end.y) {
        pt = rline.start;
        po = rline.end;
    } else {
        pt = rline.end;
        po = rline.start;
    }

    var v = vector(pt, {x: pt.x, y: 0});
    pt = translate(pt, v);
    po = translate(po, v);
    p = translate(p, v);
    // Step 2:
    var ang = angle({x: po.x - pt.x, y: po.y - pt.y}, {x: pt.x - po.x, y: 0});
    po = rotate(po, pt, Math.cos(-ang), Math.sin(-ang));
    p = rotate(p, pt, Math.cos(-ang), Math.sin(-ang));

    // Step 3:
    p = mirrorP(p);

    //Step 4:
    //po = rotate(po, pt, Math.cos(-ang), -Math.sin(-ang));
    p = rotate(p, pt, -Math.cos(-ang), Math.sin(-ang));

    // Step 5:
    v = {x: -v.x, y: -v.y};
    //pt = translate(pt, v);
    //po = translate(po, v);
    p = translate(p, v);


    return new Point(p.y, p.y);
}

// Espelha o ponto p em relação ao eixo x
function mirrorP(p) {
    var pMirrored = {x: 0, y: 0};
    var m1 = [
      [1, 0, 0],
      [0, -1, 0],
      [0, 0, 1]
    ];
    var m2 = [
      [p.x],
      [p.y],
      [1]
    ];
    var m = multMatrix(m1, m2);
    pMirrored.x = m[0][0];
    pMirrored.y = m[1][0];

    return pMirrored;
}
*/

function midPoint(p1, p2) {
    return {x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2};
}

// Calcula o ângulo entre dois vetores
// Fórmula: arcos(a) = v1 . v2
//                   -----------
//                   |v1| * |v2|
function angle(v1, v2) {
    var vp = (v1.x * v2.x) + (v1.y * v2.y);
    var vm = (Math.sqrt(Math.pow(v1.x, 2) + Math.pow(v1.y, 2))) * (Math.sqrt(Math.pow(v2.x, 2) + Math.pow(v2.y, 2)));
    return Math.acos(vp / vm);
}

function convexHull(points) {
    points.sort(function (a, b) {
        return a.x != b.x ? a.x - b.x : a.y - b.y;
    });

    var n = points.length;
    var hull = [];

    for (var i = 0; i < 2 * n; i++) {
        var j = i < n ? i : 2 * n - 1 - i;
        while (hull.length >= 2 && removeMiddle(hull[hull.length - 2], hull[hull.length - 1], points[j]))
            hull.pop();
        hull.push(points[j]);
    }

    hull.pop();
    return hull;
}

function removeMiddle(a, b, c) {
    var cross = (a.x - b.x) * (c.y - b.y) - (a.y - b.y) * (c.x - b.x);
    var dot = (a.x - b.x) * (c.x - b.x) + (a.y - b.y) * (c.y - b.y);
    return cross < 0 || cross == 0 && dot <= 0;
}

</script>
</html>